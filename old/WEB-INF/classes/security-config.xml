<?xml version="1.0" encoding="UTF-8"?>
<!-- documentation see: http://static.springsource.org/spring-security/site/reference.html -->
<beans:beans xmlns="http://www.springframework.org/schema/security"
	xmlns:beans="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:oauth="http://www.springframework.org/schema/security/oauth2"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/security/oauth2
		   http://www.springframework.org/schema/security/spring-security-oauth2-1.0.xsd
		   http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd
           http://www.springframework.org/schema/security
           http://www.springframework.org/schema/security/spring-security-3.2.xsd">

	<http name="swaggerUIFilterChain" pattern="/docs/**" security="none" />
	
	<http name="swaggerDocFilterChain" pattern="/api/v1/api-docs/**" security="none" />

	<!-- This filter chain is used when a client tries to obtain an OAuth access token. -->
	<http name="oauthFilterChain"
		create-session="stateless" 
		pattern="/api/v1/oauth/token"
		authentication-manager-ref="clientAuthenticationManager">	
		<intercept-url 
			pattern="/api/v1/oauth/token" 
			access="IS_AUTHENTICATED_FULLY"/>
		<anonymous enabled="false"/>
		<access-denied-handler ref="oauthAccessDeniedHandler"/>
		<http-basic entry-point-ref="clientAuthenticationEntryPoint"/>
	</http>

	<!-- This filter chain is used when a client tries to gain access to a protected rest resource. -->
	<http name="restFilterChain"
		create-session="stateless" 
		pattern="/api/v1/**"
		entry-point-ref="oauthAuthenticationEntryPoint" 
		authentication-manager-ref="clientAuthenticationManager"
		access-decision-manager-ref="accessDecisionManager">	
		<custom-filter 
			ref="resourceServerFilter" 
			before="PRE_AUTH_FILTER"/><!-- 
		
		Authorization on fail-safe actions 
		
		Case Events 
		
			read 
			--><intercept-url 
				pattern="/api/v1/displaynamesmigration/**" 
				method="GET" 
				access="PERM_MIGRATION_MANAGER,
						PERM_ALL_ALL"/><!-- 
		
		Case Events 
		
			read 
			--><intercept-url 
				pattern="/api/v1/caseEvents/**" 
				method="GET" 
				access="PERM_CASE_EVENTS_READ,
						PERM_CASE_EVENTS_ALL,
						PERM_ALL_READ,
						PERM_ALL_ALL"/><!-- 
						
			create
			 
			--><intercept-url 
				pattern="/api/v1/caseEvents/**" 
				method="POST" 
				access="PERM_CASE_EVENTS_CREATE,
						PERM_CASE_EVENTS_ALL,
						PERM_ALL_CREATE,
						PERM_ALL_ALL"/><!--
						 
		End Case Events 
		
	 	Cases 
			
			read 
			--><intercept-url
				pattern="/api/v1/cases/**"
				method="GET"
				access="PERM_CASES_READ,
						PERM_CASES_ALL,
						PERM_ALL_READ,
						PERM_ALL_ALL"/><!-- 
		
		End Cases 
		
		Endpoints
		
			read 
			--><intercept-url
				pattern="/api/v1/endpoints/**"
				method="GET"
				access="PERM_ENDPOINTS_READ,
						PERM_ENDPOINTS_ALL,
						PERM_ALL_READ,
						PERM_ALL_ALL"/><!-- 
		
		End Endpoints
		
		Projects
		
			read 
			--><intercept-url
				pattern="/api/v1/projects/**"
				method="GET"
				access="PERM_PROJECTS_READ,
						PERM_PROJECTS_ALL,
						PERM_ALL_READ,
						PERM_ALL_ALL"/><!-- 
		
		End Projects
		
		Shortcuts 
		
			read 
			--><intercept-url 
				pattern="/api/v1/shortcuts/**"
				method="GET"
				access="PERM_SHORTCUTS_READ,
						PERM_SHORTCUTS_ALL,
						PERM_ALL_READ,
						PERM_ALL_ALL"/><!-- 
						
		End Shortcuts
		
		Tasks 
			
			read 
			--><intercept-url 
				pattern="/api/v1/tasks/**" 
				method="GET" 
				access="PERM_TASKS_READ,
						PERM_TASKS_ALL,
						PERM_ALL_READ,
						PERM_ALL_ALL"/><!-- 
						
			update 
			--><intercept-url 
				pattern="/api/v1/tasks/**" 
				method="PUT" 
				access="PERM_TASKS_UPDATE,
						PERM_TASKS_ALL,
						PERM_ALL_UPDATE,
						PERM_ALL_ALL"/><!-- 
		
		End Tasks 
		
		Runtime 
		
			read 
			--><intercept-url
				pattern="/api/v1/**"
				method="GET"
				access="PERM_RUNTIME_READ,
						PERM_RUNTIME_ALL,
						PERM_ALL_READ,
						PERM_ALL_ALL"/><!-- 
		
		End Runtime
		
		--><intercept-url 
			pattern="/api/v1/**" 
			access="IS_AUTHENTICATED_FULLY"/>
		<access-denied-handler ref="oauthAccessDeniedHandler"/>
	</http>
	
	<http auto-config="true" use-expressions="true">
  		<session-management session-fixation-protection="none" />
        <intercept-url pattern="/server/noaccess.html" access="isAuthenticated()" />
        <intercept-url pattern="/VAADIN/**" access="true" />
        <intercept-url pattern="/server/**" access="true" />       
    	<form-login always-use-default-target="true" default-target-url="/server/start?loginSuccess=true" login-page="/server/session/login.html" />
    	<anonymous enabled="true" key="doesNotMatter" />
    </http>

    <authentication-manager alias="authenticationManager">
        <authentication-provider>
            <user-service properties="aquima:users.properties" />
        </authentication-provider>
        <authentication-provider ref="anonymousAuthenticationProvider" />
    </authentication-manager>
    
    <beans:bean id="anonymousAuthenticationProvider" class="org.springframework.security.authentication.AnonymousAuthenticationProvider">
    	<beans:property name="key" value="doesNotMatter" />
    </beans:bean>
    
	<!-- This bean is a strategy for the restFilterChain which is executed when a client is not authenticated (with an access token). 
	It  responds with the standard 401 Unauthorized message, but with a Content-Type requested by the client. -->
	<beans:bean id="oauthAuthenticationEntryPoint" 
		class="org.springframework.security.oauth2.provider.error.OAuth2AuthenticationEntryPoint">
		<beans:property name="realmName" value="Runtime/Client"/>
	</beans:bean>

	<!-- This bean is a strategy for the HTTP Basic Authentication filter, and it is executed when a client is not authenticated (with client-id/secret).
	This strategy responds with the standard 401 Unauthorized message, but with a Content-Type requested by the client. -->
	<beans:bean id="clientAuthenticationEntryPoint" 
		class="org.springframework.security.oauth2.provider.error.OAuth2AuthenticationEntryPoint">
		<beans:property name="realmName" value="Runtime"/>
		<beans:property name="typeName" value="Basic"/>
	</beans:bean>

	<!-- This bean is shared between the oauthTokenFiltnerChain and restFilterChain. 
	It is activated when a client is authenticated, but not authorized for the resource it is trying to gain access to. 
	In case of the oauthTokenFilterChain, it is activated when the client requests a grant type for which he is not authorized. 
	In case of the restFilterChain, it is activated when the client and/or the user on behalf of which it acts are not authorized to gain access to a protected resource.
	The action performed by this bean is to send a 403 Forbidden message, but with a Content-Type requested by the client. -->
	<beans:bean id="oauthAccessDeniedHandler" 	
		class="org.springframework.security.oauth2.provider.error.OAuth2AccessDeniedHandler"/>
    
	<beans:bean id="clientDetailsUserService" 
		class="org.springframework.security.oauth2.provider.client.ClientDetailsUserDetailsService">
   	 	<beans:constructor-arg ref="clientDetailsService"/>
	</beans:bean>

	<!-- The token store is responsible for saving and loading tokens. Since the authorization server and the resource server are the same, 
	and there is no need to preserver access tokens across server restarts, an in-memory token store is sufficient. -->
	<beans:bean id="tokenStore" 
		class="org.springframework.security.oauth2.provider.token.InMemoryTokenStore"/>

	<beans:bean id="tokenServices" 
		class="org.springframework.security.oauth2.provider.token.DefaultTokenServices">
		<beans:property name="tokenStore" ref="tokenStore"/>
	    <beans:property name="supportRefreshToken" value="false"/>
	    <beans:property name="accessTokenValiditySeconds" value="4000"/>
	    <beans:property name="clientDetailsService" ref="clientDetailsService"/>
	</beans:bean>
	
	<!-- The UnanimousBased manager uses multiple AccessDecisionVoters, who must unanimously vote to grant access. 
	This bean is configured with two voters, authenticatedVoter and roleVoter. -->
	<beans:bean id="accessDecisionManager" 
		class="org.springframework.security.access.vote.AffirmativeBased">
		<beans:constructor-arg>
			<beans:list>
				<!-- This is an AccessDecisionVoter who votes to grant access if the current user is authenticated. -->
				<beans:bean class="org.springframework.security.access.vote.AuthenticatedVoter"/>
				<!-- This is an AccessDecisionVoter who votes to grant access if the current user has the roles defined in filter chain using <intercep-url access="...">. -->
				<beans:bean class="com.aquima.web.security.PermissionVoter">
					<beans:constructor-arg ref="permProvider" />
					<beans:constructor-arg value="PERM_" />
				</beans:bean>
			</beans:list>
		</beans:constructor-arg>
	</beans:bean>
	
	<beans:bean id="permProvider"
		class="com.aquima.web.security.InMemoryRolePermissionsProvider">
		<beans:property name="location">
			<beans:value>aquima:permissions.properties</beans:value>
		</beans:property>
		<beans:property name="ignoreResourceNotFound">
			<beans:value>true</beans:value>
		</beans:property>
	</beans:bean>
	
	<!-- This manager authenticates clients. It is used in the oauthTokenFilterChain and restFilterChain filter chains. -->
	<authentication-manager id="clientAuthenticationManager">
		<authentication-provider user-service-ref="clientDetailsUserService"/>
	</authentication-manager>
	
	<beans:bean 
		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<beans:property name="location">
			<beans:value>aquima:aquima.properties</beans:value>
		</beans:property>
		<beans:property name="ignoreUnresolvablePlaceholders">
			<beans:value>true</beans:value>
		</beans:property>
		<beans:property name="ignoreResourceNotFound">
			<beans:value>true</beans:value>
		</beans:property>
	</beans:bean>
	
  	<!-- This service loads clients by client-id. The Spring configuration defines only one client. 
	The client-id and secret could be read from a properties file in the future. -->
	<beans:bean id="clientDetailsService" class="com.aquima.web.security.RestClientDetailsService">
		<beans:property name="properties">
			<util:properties location="aquima:aquima.properties"/>
		</beans:property>
	</beans:bean>

	<oauth:authorization-server client-details-service-ref="clientDetailsService" token-services-ref="tokenServices">
		<oauth:password authentication-manager-ref="authenticationManager"/>
	</oauth:authorization-server>
	
	<!-- This filter is used in the restFilterChain to check and verify the OAuth2 access token. 
	Behind the scenes, Spring creates an OAuth2AuthenticationProcessingFilter and an OAuth2AuthenticationManager which do the actual checking. 
	The reference to the tokenServices bean is needed in order to load the authentication details associated with a token 
	(which were established beforehand in the oauthTokenFilterChain). -->
	<oauth:resource-server id="resourceServerFilter" token-services-ref="tokenServices"/> 
    
</beans:beans>
